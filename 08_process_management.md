# 8 章 プロセス管理（要約）

Linux のシステムは、多数のプログラムが同時に動作し、それらを「プロセス」として管理します。本章では、プロセスの基本概念、確認方法、制御方法について学びます。

---

## 目次

- [8-1 プロセスとは](#8-1-プロセスとは)
  - [8-1-1 ps コマンドでプロセスを確認する](#8-1-1-ps-コマンドでプロセスを確認する)
  - [8-1-2 プロセスの親子関係を確認する](#8-1-2-プロセスの親子関係を確認する)
  - [8-1-3 プロセスを実行したユーザーを確認する](#8-1-3-プロセスを実行したユーザーを確認する)
  - [8-1-4 バックグラウンド動作しているプロセスを確認する](#8-1-4-バックグラウンド動作しているプロセスを確認する)
  - [8-1-5 制御端末のあるすべてのプロセスを確認する](#8-1-5-制御端末のあるすべてのプロセスを確認する)
  - [8-1-6 すべてのプロセスを確認する](#8-1-6-すべてのプロセスを確認する)
  - [8-1-7 pstree コマンド](#8-1-7-pstree-コマンド)
- [8-2 top コマンド](#8-2-top-コマンド)
- [8-3 シグナルによるプロセスの制御](#8-3-シグナルによるプロセスの制御)
  - [8-3-1 シグナル番号とシグナル名](#8-3-1-シグナル番号とシグナル名)
  - [8-3-2 kill コマンドによるシグナル送信](#8-3-2-kill-コマンドによるシグナル送信)

---

## 本章の内容

- プロセスとは
- top コマンド
- シグナルによるプロセスの制御

---

## 8-1 プロセスとは

- Linux では **実行中のプログラム = プロセス** として扱う。
- コマンド実行に使うシェルもプロセスの一つ。
- シェルからコマンドを実行すると、そのプログラムが新たに **プロセス** として生成され、Linux カーネルが管理する。
- プログラムが終了すると、対応するプロセスも終了する。

### 親プロセスと子プロセス

- **親プロセス** : ほかのプロセスを生成するプロセス。
- **子プロセス** : 親プロセスによって生成されたプロセス。
- 例: シェルからコマンドを実行すると、シェルが親プロセス、実行したコマンドが子プロセスとなる。

---

### 8-1-1 ps コマンドでプロセスを確認する

#### ポイント

- `ps` コマンドは **現在動作中のプロセスを表示** する。
- オプションを組み合わせることで、詳細表示が可能。

#### 主なオプション

- `a` : すべてのプロセスを表示
- `f` : プロセスの親子関係を表示
- `u` : 実行ユーザーを表示
- `x` : 制御端末を持たないバックグラウンドプロセスも表示

#### 実行例

```bash

$ ps
  PID TTY          TIME CMD
 3306 pts/1    00:00:00 bash
 3356 pts/1    00:00:00 ps

```

- オプションなしでは、現在のシェル (bash) と ps コマンド自体のみが表示される。

---

### 8-1-2 プロセスの親子関係を確認する

#### ポイント

- `ps f` を使うと、**プロセスの親子関係** をツリー状に表示できる。
- シェルから起動した `ps` コマンドが **子プロセス** として見える。
- GUI 環境を利用するためのプロセスも同時に確認できる。

#### 実行例

```bash

$ ps f
  PID TTY      STAT TIME COMMAND
 2618 pts/0    Ss+  0:00 bash
 3362 pts/0    R+   0:00  \_ ps f
 1816 tty2     Ssl+ 0:00 /usr/libexec/gdm -wayland -session --register -session
 1823 tty2     Sl+  0:00  \_ /usr/libexec/gnome -session -binary

```

- ps は bash の子プロセスとして実行されていることがわかる。

- GUI のセッション管理に必要なプロセス（gdm, gnome-session など）も表示される。

---

### 8-1-3 プロセスを実行したユーザーを確認する

#### ポイント

- `ps u` を使うと、**プロセスを実行したユーザー情報** を表示できる。
- CPU 使用率・メモリ使用率・開始時間などのリソース情報も確認できる。

#### 実行例

```bash

$ ps u
USER     PID  %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
linuc   1816  0.0  0.4 375108  7644 tty2     Ssl+ 10:30   0:00 /usr/libexec/
linuc   1823  0.0  1.0 518668 17776 tty2     Sl+  10:30   0:00 /usr/libexec/
linuc   2618  0.0  0.3 223940  5120 pts/0    Ss+  10:32   0:00 bash
linuc   3368  0.0  0.1 225488  3072 pts/0    R+   15:03   0:00 ps u

```

- ユーザー linuc が各プロセスを実行していることが確認できる。
- リソース状況（CPU・メモリ使用率など）も同時にわかる。

---

### 8-1-4 バックグラウンド動作しているプロセスを確認する

#### ポイント

- Linux では、シェルから起動したプロセス以外にも多くのプロセスがシステムを構成している。
- `ps x` を使うと、**制御端末を持たないバックグラウンドプロセス** も表示できる。
- 表示項目の **TTY** が `?` の場合、そのプロセスは制御端末を持たずバックグラウンドで動作中。

#### 実行例

```bash

$ ps x
  PID TTY      STAT TIME COMMAND
 1786 ?        Ss   0:00 /usr/lib/systemd/systemd --user
 1788 ?        S    0:00 (sd-pam)
 1807 ?        Sl   0:00 /usr/bin/gnome-keyring-daemon --daemonize --login
 1816 tty2     Ssl+ 0:00 /usr/libexec/gdm -wayland -session --register -session
 2618 pts/0    Ss+  0:00 bash
 3369 pts/0    R+   0:00 ps x

```

- TTY が ? のプロセスはバックグラウンドで動作している。
- シェル (bash) 以外にも、GUI やシステム管理に必要なプロセスが確認できる.

---

### 8-1-5 制御端末のあるすべてのプロセスを確認する

#### ポイント

- Linux 全体で、**制御端末を持つすべてのプロセス** を確認するには `ps a` を使用する。
- GUI セッションやシェルで動作しているプロセスが表示される。

#### 実行例

```bash

$ ps a
  PID TTY      STAT TIME COMMAND
 1816 tty2     Ssl+ 0:00 /usr/libexec/gdm -wayland -session --register -session
 1823 tty2     Sl+  0:00 /usr/libexec/gnome-session-binary
 2618 pts/0    Ss+  0:00 bash
 3376 pts/0    R+   0:00 ps a

```

- GUI のためのプロセス (gdm, gnome-session など) が動作していることがわかる。
- 自分のシェル (bash) とそこから実行した ps も表示される。

---

### 8-1-6 すべてのプロセスを確認する

#### ポイント

- `ps ax` を使うと、**制御端末の有無に関わらずすべてのプロセス** が表示される。
- バックグラウンドプロセスやカーネルスレッドも確認可能。
- プロセス ID **1** は、カーネル起動後に最初に実行されるプロセスで、通常は **systemd** が起動している。

#### 実行例

```bash

$ ps ax
   PID TTY      STAT TIME COMMAND
     1 ?        Ss   0:00 /usr/lib/systemd/systemd rhgb --switched-root --system --deserialize ...
     2 ?        S    0:00 [kthreadd]
    ...（略）...

```

- PID 1 は systemd で、Linux のサービスやプロセス管理の基盤となる。
- kthreadd などのカーネルスレッドも確認できる。

---

### 8-1-7 pstree コマンド

#### ポイント

- `pstree` コマンドは、**プロセスの親子関係をツリー形式** で表示する。
- `ps f` でも親子関係を確認できるが、`pstree` の方がより見やすい。

#### 実行例

```bash

$ pstree
systemd─┬─ModemManager───3*[{ModemManager}]
        ├─NetworkManager───2*[{NetworkManager}]
        ├─gnome-session───…
        └─bash───pstree

```

- 各プロセスの 親子関係や並び が一目でわかる。
- [{ ... }] のようにスレッド数をまとめて表示してくれる。

---

### 8-2 top コマンド

- `top` は **実行中のプロセスをリアルタイム表示** するツール。
- CPU・メモリ使用率でソート可能。
- システム全体のリソース状況を確認できる。

#### 主なキー操作

| キー操作   | 説明                                           |
| ---------- | ---------------------------------------------- |
| `?`        | ヘルプ表示                                     |
| `スペース` | 画面更新                                       |
| `1`        | CPU ごとの使用率表示                           |
| `P`        | CPU 使用率でソート                             |
| `M`        | メモリ使用率でソート                           |
| `<` / `>`  | ソート項目の切替                               |
| `x`        | ソート対象をハイライト                         |
| `b`        | ソート対象を強調表示（※`x`と組み合わせて`xb`） |
| `q`        | 終了                                           |

#### 実行例

```bash

$ top

```

- xb と入力すると、ソート対象項目を強調して見やすくできる。

---

### 8-3 シグナルによるプロセスの制御

- プロセスは以下の方法で終了または停止させることができる。

  - 正常終了（処理完了時）

  - 異常終了（エラー時）

  - 外部からのシグナル送信

#### シグナル送信方法

##### 1. 端末でキー入力

- **Ctrl+c** : 実行中のプロセスを強制終了（`SIGINT`）
- **Ctrl+z** : 実行中のプロセスを一時停止（`SIGTSTP`）

##### 2. kill コマンド

- 指定したプロセスにシグナルを送信し、終了や制御を行う。
- 例:

```bash

# プロセスID 1234 に SIGTERM を送る（通常終了）
kill 1234

# プロセスID 1234 に SIGKILL を送る（強制終了）
kill -9 1234

```

---

### 8-3-1 シグナル番号とシグナル名

- シグナルには番号と名前が割り当てられており、代表的なものは以下の通りです。

#### 代表的なシグナル

| 番号 | 名前 | 説明                       |
| ---- | ---- | -------------------------- |
| 1    | HUP  | ハングアップ（切断時など） |
| 9    | KILL | 強制終了（捕捉不可）       |
| 15   | TERM | 通常終了（デフォルト）     |
| 18   | TSTP | 停止（Ctrl+Z）             |

#### シグナル一覧の確認方法

`kill` コマンドに `-l` オプションをつけると、システムで利用可能なシグナル一覧が表示されます。

```bash

$ kill -l
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL
 5) SIGTRAP  6) SIGABRT  7) SIGEMT   8) SIGFPE
 9) SIGKILL 10) SIGBUS  11) SIGSEGV 12) SIGSYS
13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGURG
17) SIGSTOP 18) SIGTSTP 19) SIGCONT 20) SIGCHLD
21) SIGTTIN 22) SIGTTOU 23) SIGIO   24) SIGXCPU
25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH
29) SIGINFO 30) SIGUSR1  31) SIGUSR2

```

---

### 8-3-2 kill コマンドによるシグナル送信

#### kill コマンドの基本

- **書式**

```bash

kill [オプション] プロセスID

```

#### オプション

- シグナル番号 : 指定したシグナルをプロセスに送信する

#### 実行例

```bash

$ sudo tail -f /var/log/messages &
[1] 22385    # ジョブ番号 [1] と プロセスID 22385 を表示
（略）
$ kill 22385
$   # Enter キーを押すと結果が表示される
[1]+ Terminated sudo tail -f /var/log/messages

```

- & をつけてコマンドを実行すると、バックグラウンドジョブとして実行される

- tail -f は終了指示がない限りログを出力し続ける

- プロンプト復帰時に表示される ジョブ番号とプロセス ID のうち、kill の引数に
  プロセス ID を指定すると終了できる

#### デフォルトと指定

- シグナル指定なし → デフォルトで 15 (SIGTERM) が送信される

- 強制終了 → 9 (KILL) を指定して送信することで制御不能なプロセスを終了できる

```bash

kill -9 プロセスID

```

---
